\doxysection{Priority\+\_\+\+Queue Namespace Reference}
\hypertarget{namespace_priority___queue}{}\label{namespace_priority___queue}\index{Priority\_Queue@{Priority\_Queue}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{class_priority___queue_1_1_fast_priority_queue-1-g}{Fast\+Priority\+Queue$<$ T $>$}}
\begin{DoxyCompactList}\small\item\em An implementation of a min-\/\+Priority Queue using a heap. Has O(1) .\doxylink{class_priority___queue_1_1_fast_priority_queue-1-g_ac7ed1c55afc22b9f492576675d0651c7}{Contains()}! See \href{https://github.com/BlueRaja/High-Speed-Priority-Queue-for-C-Sharp/wiki/Getting-Started}{\texttt{https\+://github.\+com/\+Blue\+Raja/\+High-\/\+Speed-\/\+Priority-\/\+Queue-\/for-\/\+C-\/\+Sharp/wiki/\+Getting-\/\+Started}} for more information. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_priority___queue_1_1_fast_priority_queue_node}{Fast\+Priority\+Queue\+Node}}
\item 
class \mbox{\hyperlink{class_priority___queue_1_1_generic_priority_queue-2-g}{Generic\+Priority\+Queue$<$ TItem, TPriority $>$}}
\begin{DoxyCompactList}\small\item\em A copy of Stable\+Priority\+Queue which also has generic priority-\/type. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_priority___queue_1_1_generic_priority_queue_node-1-g}{Generic\+Priority\+Queue\+Node$<$ TPriority $>$}}
\item 
interface {\bfseries IFixed\+Size\+Priority\+Queue$<$ TItem, in TPriority $>$}
\begin{DoxyCompactList}\small\item\em A helper-\/interface only needed to make writing unit tests a bit easier (hence the \textquotesingle{}internal\textquotesingle{} access modifier) \end{DoxyCompactList}\item 
interface \mbox{\hyperlink{interface_priority___queue_1_1_i_priority_queue-2-g}{IPriority\+Queue$<$ TItem, in TPriority $>$}}
\begin{DoxyCompactList}\small\item\em The IPriority\+Queue interface. This is mainly here for purists, and in case I decide to add more implementations later. For speed purposes, it is actually recommended that you {\itshape don\textquotesingle{}t} access the priority queue through this interface, since the JIT can (theoretically?) optimize method calls from concrete-\/types slightly better. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_priority___queue_1_1_simple_priority_queue-1-g}{Simple\+Priority\+Queue$<$ TItem $>$}}
\begin{DoxyCompactList}\small\item\em A simplified priority queue implementation. Is stable, auto-\/resizes, and thread-\/safe, at the cost of being slightly slower than Fast\+Priority\+Queue This class is kept here for backwards compatibility. It\textquotesingle{}s recommended you use Simple\+Priority\+Queue\texorpdfstring{$<$}{<}TItem, TPriority\texorpdfstring{$>$}{>}. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_priority___queue_1_1_simple_priority_queue-2-g}{Simple\+Priority\+Queue$<$ TItem, TPriority $>$}}
\begin{DoxyCompactList}\small\item\em A simplified priority queue implementation. Is stable, auto-\/resizes, and thread-\/safe, at the cost of being slightly slower than Fast\+Priority\+Queue Methods tagged as O(1) or O(log n) are assuming there are no duplicates. Duplicates may increase the algorithmic complexity. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_priority___queue_1_1_stable_priority_queue-1-g}{Stable\+Priority\+Queue$<$ T $>$}}
\begin{DoxyCompactList}\small\item\em A copy of Fast\+Priority\+Queue which is also stable -\/ that is, when two nodes are enqueued with the same priority, they are always dequeued in the same order. See \href{https://github.com/BlueRaja/High-Speed-Priority-Queue-for-C-Sharp/wiki/Getting-Started}{\texttt{https\+://github.\+com/\+Blue\+Raja/\+High-\/\+Speed-\/\+Priority-\/\+Queue-\/for-\/\+C-\/\+Sharp/wiki/\+Getting-\/\+Started}} for more information. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_priority___queue_1_1_stable_priority_queue_node}{Stable\+Priority\+Queue\+Node}}
\end{DoxyCompactItemize}
